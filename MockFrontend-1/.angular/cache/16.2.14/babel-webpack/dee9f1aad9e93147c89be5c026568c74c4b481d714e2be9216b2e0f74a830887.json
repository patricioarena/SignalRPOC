{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Arg, Subject } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\n/** Represents a connection to a SignalR Hub. */\nvar HubConnection = /** @class */function () {\n  function HubConnection(connection, logger, protocol) {\n    var _this = this;\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.handshakeProtocol = new HandshakeProtocol();\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.id = 0;\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n  HubConnection.create = function (connection, logger, protocol) {\n    return new HubConnection(connection, logger, protocol);\n  };\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n  HubConnection.prototype.start = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakeRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n            this.receivedHandshakeResponse = false;\n            return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\n          case 1:\n            _a.sent();\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n            return [4 /*yield*/, this.connection.send(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n          case 2:\n            _a.sent();\n            this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\n            this.cleanupTimeout();\n            this.configureTimeout();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n  HubConnection.prototype.stop = function () {\n    this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n    this.cleanupTimeout();\n    return this.connection.stop();\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var invocationDescriptor = this.createStreamInvocation(methodName, args);\n    var subject = new Subject(function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n      var cancelMessage = _this.protocol.writeMessage(cancelInvocation);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return _this.connection.send(cancelMessage);\n    });\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      }\n      if (invocationEvent.type === MessageType.Completion) {\n        if (invocationEvent.error) {\n          subject.error(new Error(invocationEvent.error));\n        } else {\n          subject.complete();\n        }\n      } else {\n        subject.next(invocationEvent.item);\n      }\n    };\n    var message = this.protocol.writeMessage(invocationDescriptor);\n    this.connection.send(message).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    return subject;\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var invocationDescriptor = this.createInvocation(methodName, args, true);\n    var message = this.protocol.writeMessage(invocationDescriptor);\n    return this.connection.send(message);\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var invocationDescriptor = this.createInvocation(methodName, args, false);\n    var p = new Promise(function (resolve, reject) {\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        }\n        if (invocationEvent.type === MessageType.Completion) {\n          var completionMessage = invocationEvent;\n          if (completionMessage.error) {\n            reject(new Error(completionMessage.error));\n          } else {\n            resolve(completionMessage.result);\n          }\n        } else {\n          reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n        }\n      };\n      var message = _this.protocol.writeMessage(invocationDescriptor);\n      _this.connection.send(message).catch(function (e) {\n        reject(e);\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n    methodName = methodName.toLowerCase();\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    }\n    // Preventing adding the same handler multiple times.\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n    this.methods[methodName].push(newMethod);\n  };\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n    if (!handlers) {\n      return;\n    }\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    }\n    // Data may have all been read when processing handshake response\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n        switch (message.type) {\n          case MessageType.Invocation:\n            this.invokeClientMethod(message);\n            break;\n          case MessageType.StreamItem:\n          case MessageType.Completion:\n            var callback = this.callbacks[message.invocationId];\n            if (callback != null) {\n              if (message.type === MessageType.Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n              callback(message);\n            }\n            break;\n          case MessageType.Ping:\n            // Don't care about pings\n            break;\n          case MessageType.Close:\n            this.logger.log(LogLevel.Information, \"Close message received from server.\");\n            // We don't want to wait on the stop itself.\n            // tslint:disable-next-line:no-floating-promises\n            this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : null);\n            break;\n          default:\n            this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type);\n            break;\n        }\n      }\n    }\n    this.configureTimeout();\n  };\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n    var responseMessage;\n    var remainingData;\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      // We don't want to wait on the stop itself.\n      // tslint:disable-next-line:no-floating-promises\n      this.connection.stop(error);\n      throw error;\n    }\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(LogLevel.Error, message);\n      // We don't want to wait on the stop itself.\n      // tslint:disable-next-line:no-floating-promises\n      this.connection.stop(new Error(message));\n    } else {\n      this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n    }\n    return remainingData;\n  };\n  HubConnection.prototype.configureTimeout = function () {\n    var _this = this;\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds);\n    }\n  };\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n    if (methods) {\n      methods.forEach(function (m) {\n        return m.apply(_this, invocationMessage.arguments);\n      });\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(LogLevel.Error, message);\n        // We don't need to wait on this Promise.\n        // tslint:disable-next-line:no-floating-promises\n        this.connection.stop(new Error(message));\n      }\n    } else {\n      this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n  HubConnection.prototype.connectionClosed = function (error) {\n    var _this = this;\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(undefined, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\n    });\n    this.cleanupTimeout();\n    this.closedCallbacks.forEach(function (c) {\n      return c.apply(_this, [error]);\n    });\n  };\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking) {\n    if (nonblocking) {\n      return {\n        arguments: args,\n        target: methodName,\n        type: MessageType.Invocation\n      };\n    } else {\n      var id = this.id;\n      this.id++;\n      return {\n        arguments: args,\n        invocationId: id.toString(),\n        target: methodName,\n        type: MessageType.Invocation\n      };\n    }\n  };\n  HubConnection.prototype.createStreamInvocation = function (methodName, args) {\n    var id = this.id;\n    this.id++;\n    return {\n      arguments: args,\n      invocationId: id.toString(),\n      target: methodName,\n      type: MessageType.StreamInvocation\n    };\n  };\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: MessageType.CancelInvocation\n    };\n  };\n  return HubConnection;\n}();\nexport { HubConnection };","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","HandshakeProtocol","MessageType","LogLevel","Arg","Subject","DEFAULT_TIMEOUT_IN_MS","HubConnection","connection","logger","protocol","_this","isRequired","serverTimeoutInMilliseconds","handshakeProtocol","onreceive","data","processIncomingData","onclose","error","connectionClosed","callbacks","methods","closedCallbacks","id","create","prototype","start","handshakeRequest","_a","name","version","log","Debug","receivedHandshakeResponse","transferFormat","send","writeHandshakeRequest","Information","cleanupTimeout","configureTimeout","stop","stream","methodName","args","_i","arguments","invocationDescriptor","createStreamInvocation","subject","cancelInvocation","createCancelInvocation","invocationId","cancelMessage","writeMessage","invocationEvent","type","Completion","Error","complete","item","message","catch","createInvocation","invoke","p","completionMessage","on","newMethod","toLowerCase","indexOf","off","method","handlers","removeIdx","splice","callback","processHandshakeResponse","messages","parseMessages","messages_1","Invocation","invokeClientMethod","StreamItem","Ping","Close","Warning","responseMessage","remainingData","parseHandshakeResponse","features","inherentKeepAlive","timeoutHandle","setTimeout","serverTimeout","invocationMessage","target","forEach","m","Object","keys","key","undefined","c","clearTimeout","nonblocking","toString","StreamInvocation","CancelInvocation"],"sources":["C:/Users/Ayelen/Desktop/SignalRPOC/MockFrontend-1/node_modules/@aspnet/signalr/dist/esm/HubConnection.js"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Arg, Subject } from \"./Utils\";\r\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\n/** Represents a connection to a SignalR Hub. */\r\nvar HubConnection = /** @class */ (function () {\r\n    function HubConnection(connection, logger, protocol) {\r\n        var _this = this;\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = function (data) { return _this.processIncomingData(data); };\r\n        this.connection.onclose = function (error) { return _this.connectionClosed(error); };\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.id = 0;\r\n    }\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    HubConnection.create = function (connection, logger, protocol) {\r\n        return new HubConnection(connection, logger, protocol);\r\n    };\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.start = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var handshakeRequest;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        handshakeRequest = {\r\n                            protocol: this.protocol.name,\r\n                            version: this.protocol.version,\r\n                        };\r\n                        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n                        this.receivedHandshakeResponse = false;\r\n                        return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n                        return [4 /*yield*/, this.connection.send(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\r\n                        // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n                        this.cleanupTimeout();\r\n                        this.configureTimeout();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.stop = function () {\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        this.cleanupTimeout();\r\n        return this.connection.stop();\r\n    };\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    HubConnection.prototype.stream = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var invocationDescriptor = this.createStreamInvocation(methodName, args);\r\n        var subject = new Subject(function () {\r\n            var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            var cancelMessage = _this.protocol.writeMessage(cancelInvocation);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n            return _this.connection.send(cancelMessage);\r\n        });\r\n        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            if (invocationEvent.type === MessageType.Completion) {\r\n                if (invocationEvent.error) {\r\n                    subject.error(new Error(invocationEvent.error));\r\n                }\r\n                else {\r\n                    subject.complete();\r\n                }\r\n            }\r\n            else {\r\n                subject.next((invocationEvent.item));\r\n            }\r\n        };\r\n        var message = this.protocol.writeMessage(invocationDescriptor);\r\n        this.connection.send(message)\r\n            .catch(function (e) {\r\n            subject.error(e);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        return subject;\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.send = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var invocationDescriptor = this.createInvocation(methodName, args, true);\r\n        var message = this.protocol.writeMessage(invocationDescriptor);\r\n        return this.connection.send(message);\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    HubConnection.prototype.invoke = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var invocationDescriptor = this.createInvocation(methodName, args, false);\r\n        var p = new Promise(function (resolve, reject) {\r\n            _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    var completionMessage = invocationEvent;\r\n                    if (completionMessage.error) {\r\n                        reject(new Error(completionMessage.error));\r\n                    }\r\n                    else {\r\n                        resolve(completionMessage.result);\r\n                    }\r\n                }\r\n                else {\r\n                    reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\r\n                }\r\n            };\r\n            var message = _this.protocol.writeMessage(invocationDescriptor);\r\n            _this.connection.send(message)\r\n                .catch(function (e) {\r\n                reject(e);\r\n                delete _this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n        });\r\n        return p;\r\n    };\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    HubConnection.prototype.on = function (methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this.methods[methodName].push(newMethod);\r\n    };\r\n    HubConnection.prototype.off = function (methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        var handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            var removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this.methods[methodName];\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    HubConnection.prototype.onclose = function (callback) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    };\r\n    HubConnection.prototype.processIncomingData = function (data) {\r\n        this.cleanupTimeout();\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            var messages = this.protocol.parseMessages(data, this.logger);\r\n            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n                var message = messages_1[_i];\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        var callback = this.callbacks[message.invocationId];\r\n                        if (callback != null) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        // We don't want to wait on the stop itself.\r\n                        // tslint:disable-next-line:no-floating-promises\r\n                        this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : null);\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this.configureTimeout();\r\n    };\r\n    HubConnection.prototype.processHandshakeResponse = function (data) {\r\n        var _a;\r\n        var responseMessage;\r\n        var remainingData;\r\n        try {\r\n            _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\r\n        }\r\n        catch (e) {\r\n            var message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            // We don't want to wait on the stop itself.\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.connection.stop(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            var message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n            // We don't want to wait on the stop itself.\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.connection.stop(new Error(message));\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        return remainingData;\r\n    };\r\n    HubConnection.prototype.configureTimeout = function () {\r\n        var _this = this;\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);\r\n        }\r\n    };\r\n    HubConnection.prototype.serverTimeout = function () {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    };\r\n    HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\r\n        var _this = this;\r\n        var methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                var message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n                // We don't need to wait on this Promise.\r\n                // tslint:disable-next-line:no-floating-promises\r\n                this.connection.stop(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\r\n        }\r\n    };\r\n    HubConnection.prototype.connectionClosed = function (error) {\r\n        var _this = this;\r\n        var callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach(function (key) {\r\n            var callback = callbacks[key];\r\n            callback(undefined, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\r\n        });\r\n        this.cleanupTimeout();\r\n        this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n    };\r\n    HubConnection.prototype.cleanupTimeout = function () {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.createInvocation = function (methodName, args, nonblocking) {\r\n        if (nonblocking) {\r\n            return {\r\n                arguments: args,\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n        else {\r\n            var id = this.id;\r\n            this.id++;\r\n            return {\r\n                arguments: args,\r\n                invocationId: id.toString(),\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n    };\r\n    HubConnection.prototype.createStreamInvocation = function (methodName, args) {\r\n        var id = this.id;\r\n        this.id++;\r\n        return {\r\n            arguments: args,\r\n            invocationId: id.toString(),\r\n            target: methodName,\r\n            type: MessageType.StreamInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCancelInvocation = function (id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    };\r\n    return HubConnection;\r\n}());\r\nexport { HubConnection };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}